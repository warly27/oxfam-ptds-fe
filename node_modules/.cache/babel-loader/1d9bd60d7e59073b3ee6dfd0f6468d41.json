{"ast":null,"code":"import _slicedToArray from \"/Users/wdelacruz/project_2021/matx-react/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useRifm } from 'rifm';\nimport { useUtils } from './useUtils';\nimport { maskedDateFormatter, getDisplayDate, checkMaskIsValidForCurrentFormat, getMaskFromCurrentFormat } from '../utils/text-field-helper';\nexport var useMaskedInput = function useMaskedInput(_ref) {\n  var _ref$acceptRegex = _ref.acceptRegex,\n      acceptRegex = _ref$acceptRegex === void 0 ? /[\\d]/gi : _ref$acceptRegex,\n      disabled = _ref.disabled,\n      disableMaskedInput = _ref.disableMaskedInput,\n      ignoreInvalidInputs = _ref.ignoreInvalidInputs,\n      inputFormat = _ref.inputFormat,\n      inputProps = _ref.inputProps,\n      label = _ref.label,\n      mask = _ref.mask,\n      onChange = _ref.onChange,\n      rawValue = _ref.rawValue,\n      readOnly = _ref.readOnly,\n      rifmFormatter = _ref.rifmFormatter,\n      TextFieldProps = _ref.TextFieldProps,\n      validationError = _ref.validationError;\n  var utils = useUtils();\n  var formatHelperText = utils.getFormatHelperText(inputFormat);\n\n  var _React$useMemo = React.useMemo(function () {\n    // formatting of dates is a quite slow thing, so do not make useless .format calls\n    if (disableMaskedInput) {\n      return {\n        shouldUseMaskedInput: false,\n        maskToUse: ''\n      };\n    }\n\n    var computedMaskToUse = getMaskFromCurrentFormat(mask, inputFormat, acceptRegex, utils);\n    return {\n      shouldUseMaskedInput: checkMaskIsValidForCurrentFormat(computedMaskToUse, inputFormat, acceptRegex, utils),\n      maskToUse: computedMaskToUse\n    };\n  }, [acceptRegex, disableMaskedInput, inputFormat, mask, utils]),\n      shouldUseMaskedInput = _React$useMemo.shouldUseMaskedInput,\n      maskToUse = _React$useMemo.maskToUse;\n\n  var formatter = React.useMemo(function () {\n    return shouldUseMaskedInput && maskToUse ? maskedDateFormatter(maskToUse, acceptRegex) : function (st) {\n      return st;\n    };\n  }, [acceptRegex, maskToUse, shouldUseMaskedInput]); // TODO: Implement with controlled vs uncontrolled `rawValue`\n\n  var parsedValue = rawValue === null ? null : utils.date(rawValue); // Track the value of the input\n\n  var _React$useState = React.useState(parsedValue),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      innerInputValue = _React$useState2[0],\n      setInnerInputValue = _React$useState2[1]; // control the input text\n\n\n  var _React$useState3 = React.useState(getDisplayDate(utils, rawValue, inputFormat)),\n      _React$useState4 = _slicedToArray(_React$useState3, 2),\n      innerDisplayedInputValue = _React$useState4[0],\n      setInnerDisplayedInputValue = _React$useState4[1]; // Inspired from autocomplete: https://github.com/mui/material-ui/blob/2c89d036dc2e16f100528f161600dffc83241768/packages/mui-base/src/AutocompleteUnstyled/useAutocomplete.js#L185:L201\n\n\n  var prevRawValue = React.useRef();\n  React.useEffect(function () {\n    var rawValueChange = rawValue !== prevRawValue.current;\n    prevRawValue.current = rawValue;\n\n    if (!rawValueChange) {\n      return;\n    }\n\n    var newParsedValue = rawValue === null ? null : utils.date(rawValue);\n    var isAcceptedValue = rawValue === null || utils.isValid(newParsedValue);\n\n    if (!isAcceptedValue || utils.isEqual(innerInputValue, newParsedValue)) {\n      return;\n    } // When dev set a new valid value, we trust them\n\n\n    var newDisplayDate = getDisplayDate(utils, rawValue, inputFormat);\n    setInnerInputValue(newParsedValue);\n    setInnerDisplayedInputValue(newDisplayDate);\n  }, [utils, rawValue, inputFormat, innerInputValue]);\n\n  var handleChange = function handleChange(text) {\n    var finalString = text === '' || text === mask ? '' : text;\n    setInnerDisplayedInputValue(finalString);\n    var date = finalString === null ? null : utils.parse(finalString, inputFormat);\n\n    if (ignoreInvalidInputs && !utils.isValid(date)) {\n      return;\n    }\n\n    setInnerInputValue(date);\n    onChange(date, finalString || undefined);\n  };\n\n  var rifmProps = useRifm({\n    value: innerDisplayedInputValue,\n    onChange: handleChange,\n    format: rifmFormatter || formatter\n  });\n  var inputStateArgs = shouldUseMaskedInput ? rifmProps : {\n    value: innerDisplayedInputValue,\n    onChange: function onChange(event) {\n      handleChange(event.currentTarget.value);\n    }\n  };\n  return _extends({\n    label: label,\n    disabled: disabled,\n    error: validationError,\n    inputProps: _extends({}, inputStateArgs, {\n      disabled: disabled,\n      placeholder: formatHelperText,\n      readOnly: readOnly,\n      type: shouldUseMaskedInput ? 'tel' : 'text'\n    }, inputProps)\n  }, TextFieldProps);\n};","map":{"version":3,"names":["_extends","React","useRifm","useUtils","maskedDateFormatter","getDisplayDate","checkMaskIsValidForCurrentFormat","getMaskFromCurrentFormat","useMaskedInput","acceptRegex","disabled","disableMaskedInput","ignoreInvalidInputs","inputFormat","inputProps","label","mask","onChange","rawValue","readOnly","rifmFormatter","TextFieldProps","validationError","utils","formatHelperText","getFormatHelperText","useMemo","shouldUseMaskedInput","maskToUse","computedMaskToUse","formatter","st","parsedValue","date","useState","innerInputValue","setInnerInputValue","innerDisplayedInputValue","setInnerDisplayedInputValue","prevRawValue","useRef","useEffect","rawValueChange","current","newParsedValue","isAcceptedValue","isValid","isEqual","newDisplayDate","handleChange","text","finalString","parse","undefined","rifmProps","value","format","inputStateArgs","event","currentTarget","error","placeholder","type"],"sources":["/Users/wdelacruz/project_2021/matx-react/node_modules/@mui/x-date-pickers/internals/hooks/useMaskedInput.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useRifm } from 'rifm';\nimport { useUtils } from './useUtils';\nimport { maskedDateFormatter, getDisplayDate, checkMaskIsValidForCurrentFormat, getMaskFromCurrentFormat } from '../utils/text-field-helper';\nexport const useMaskedInput = ({\n  acceptRegex = /[\\d]/gi,\n  disabled,\n  disableMaskedInput,\n  ignoreInvalidInputs,\n  inputFormat,\n  inputProps,\n  label,\n  mask,\n  onChange,\n  rawValue,\n  readOnly,\n  rifmFormatter,\n  TextFieldProps,\n  validationError\n}) => {\n  const utils = useUtils();\n  const formatHelperText = utils.getFormatHelperText(inputFormat);\n  const {\n    shouldUseMaskedInput,\n    maskToUse\n  } = React.useMemo(() => {\n    // formatting of dates is a quite slow thing, so do not make useless .format calls\n    if (disableMaskedInput) {\n      return {\n        shouldUseMaskedInput: false,\n        maskToUse: ''\n      };\n    }\n\n    const computedMaskToUse = getMaskFromCurrentFormat(mask, inputFormat, acceptRegex, utils);\n    return {\n      shouldUseMaskedInput: checkMaskIsValidForCurrentFormat(computedMaskToUse, inputFormat, acceptRegex, utils),\n      maskToUse: computedMaskToUse\n    };\n  }, [acceptRegex, disableMaskedInput, inputFormat, mask, utils]);\n  const formatter = React.useMemo(() => shouldUseMaskedInput && maskToUse ? maskedDateFormatter(maskToUse, acceptRegex) : st => st, [acceptRegex, maskToUse, shouldUseMaskedInput]); // TODO: Implement with controlled vs uncontrolled `rawValue`\n\n  const parsedValue = rawValue === null ? null : utils.date(rawValue); // Track the value of the input\n\n  const [innerInputValue, setInnerInputValue] = React.useState(parsedValue); // control the input text\n\n  const [innerDisplayedInputValue, setInnerDisplayedInputValue] = React.useState(getDisplayDate(utils, rawValue, inputFormat)); // Inspired from autocomplete: https://github.com/mui/material-ui/blob/2c89d036dc2e16f100528f161600dffc83241768/packages/mui-base/src/AutocompleteUnstyled/useAutocomplete.js#L185:L201\n\n  const prevRawValue = React.useRef();\n  React.useEffect(() => {\n    const rawValueChange = rawValue !== prevRawValue.current;\n    prevRawValue.current = rawValue;\n\n    if (!rawValueChange) {\n      return;\n    }\n\n    const newParsedValue = rawValue === null ? null : utils.date(rawValue);\n    const isAcceptedValue = rawValue === null || utils.isValid(newParsedValue);\n\n    if (!isAcceptedValue || utils.isEqual(innerInputValue, newParsedValue)) {\n      return;\n    } // When dev set a new valid value, we trust them\n\n\n    const newDisplayDate = getDisplayDate(utils, rawValue, inputFormat);\n    setInnerInputValue(newParsedValue);\n    setInnerDisplayedInputValue(newDisplayDate);\n  }, [utils, rawValue, inputFormat, innerInputValue]);\n\n  const handleChange = text => {\n    const finalString = text === '' || text === mask ? '' : text;\n    setInnerDisplayedInputValue(finalString);\n    const date = finalString === null ? null : utils.parse(finalString, inputFormat);\n\n    if (ignoreInvalidInputs && !utils.isValid(date)) {\n      return;\n    }\n\n    setInnerInputValue(date);\n    onChange(date, finalString || undefined);\n  };\n\n  const rifmProps = useRifm({\n    value: innerDisplayedInputValue,\n    onChange: handleChange,\n    format: rifmFormatter || formatter\n  });\n  const inputStateArgs = shouldUseMaskedInput ? rifmProps : {\n    value: innerDisplayedInputValue,\n    onChange: event => {\n      handleChange(event.currentTarget.value);\n    }\n  };\n  return _extends({\n    label,\n    disabled,\n    error: validationError,\n    inputProps: _extends({}, inputStateArgs, {\n      disabled,\n      placeholder: formatHelperText,\n      readOnly,\n      type: shouldUseMaskedInput ? 'tel' : 'text'\n    }, inputProps)\n  }, TextFieldProps);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}